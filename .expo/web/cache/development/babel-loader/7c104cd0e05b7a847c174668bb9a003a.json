{"ast":null,"code":"export var calculateLabelTopPosition = function calculateLabelTopPosition(labelHeight) {\n  var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var optionalPadding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var customHeight = height > 0 ? height : 0;\n  return Math.floor((customHeight - labelHeight) / 2 + optionalPadding);\n};\nexport var calculateInputHeight = function calculateInputHeight(labelHeight) {\n  var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var minHeight = arguments.length > 2 ? arguments[2] : undefined;\n  var finalHeight = height > 0 ? height : labelHeight;\n  if (height > 0) return height;\n  return finalHeight < minHeight ? minHeight : finalHeight;\n};\nexport var calculatePadding = function calculatePadding(props) {\n  var height = props.height,\n      _props$multiline = props.multiline,\n      multiline = _props$multiline === void 0 ? false : _props$multiline;\n  var result = 0;\n\n  if (multiline) {\n    if (height && multiline) {\n      result = calculateTextAreaPadding(props);\n    } else {\n      result = calculateInputPadding(props);\n    }\n  }\n\n  return Math.max(0, result);\n};\n\nvar calculateTextAreaPadding = function calculateTextAreaPadding(props) {\n  var dense = props.dense;\n  return dense ? 10 : 20;\n};\n\nvar calculateInputPadding = function calculateInputPadding(_ref) {\n  var topPosition = _ref.topPosition,\n      fontSize = _ref.fontSize,\n      multiline = _ref.multiline,\n      scale = _ref.scale,\n      dense = _ref.dense,\n      offset = _ref.offset,\n      isAndroid = _ref.isAndroid;\n  var refFontSize = scale * fontSize;\n  var result = Math.floor(topPosition / 2);\n  result = result + Math.floor((refFontSize - fontSize) / 2) - (scale < 1 ? offset / 2 : 0);\n  if (multiline && isAndroid) result = Math.min(dense ? offset / 2 : offset, result);\n  return result;\n};\n\nexport var adjustPaddingOut = function adjustPaddingOut(_ref2) {\n  var pad = _ref2.pad,\n      multiline = _ref2.multiline,\n      label = _ref2.label,\n      scale = _ref2.scale,\n      height = _ref2.height,\n      fontSize = _ref2.fontSize,\n      dense = _ref2.dense,\n      offset = _ref2.offset,\n      isAndroid = _ref2.isAndroid;\n  var refFontSize = scale * fontSize;\n  var result = pad;\n\n  if (height) {\n    return {\n      paddingTop: Math.max(0, (height - fontSize) / 2),\n      paddingBottom: Math.max(0, (height - fontSize) / 2)\n    };\n  }\n\n  if (!isAndroid && multiline) {\n    if (dense) {\n      if (label) {\n        result += scale < 1 ? Math.min(offset, refFontSize / 2 * scale) : 0;\n      } else {\n        result += 0;\n      }\n    }\n\n    if (!dense) {\n      if (label) {\n        result += scale < 1 ? Math.min(offset, refFontSize * scale) : Math.min(offset / 2, refFontSize * scale);\n      } else {\n        result += scale < 1 ? Math.min(offset / 2, refFontSize * scale) : 0;\n      }\n    }\n\n    result = Math.floor(result);\n  }\n\n  return {\n    paddingTop: result,\n    paddingBottom: result\n  };\n};\nexport var adjustPaddingFlat = function adjustPaddingFlat(_ref3) {\n  var pad = _ref3.pad,\n      scale = _ref3.scale,\n      multiline = _ref3.multiline,\n      label = _ref3.label,\n      height = _ref3.height,\n      offset = _ref3.offset,\n      dense = _ref3.dense,\n      fontSize = _ref3.fontSize,\n      isAndroid = _ref3.isAndroid,\n      styles = _ref3.styles;\n  var result = pad;\n  var topResult = result;\n  var bottomResult = result;\n  var paddingTop = styles.paddingTop,\n      paddingBottom = styles.paddingBottom;\n  var refFontSize = scale * fontSize;\n\n  if (!multiline) {\n    if (label) {\n      return {\n        paddingTop: paddingTop,\n        paddingBottom: paddingBottom\n      };\n    }\n\n    return {\n      paddingTop: result,\n      paddingBottom: result\n    };\n  }\n\n  if (label) {\n    topResult = paddingTop;\n    bottomResult = paddingBottom;\n\n    if (!isAndroid) {\n      if (dense) {\n        topResult += scale < 1 ? Math.min(result, refFontSize * scale) - result / 2 : Math.min(result, refFontSize * scale) - result / 2;\n      }\n\n      if (!dense) {\n        topResult += scale < 1 ? Math.min(offset / 2, refFontSize * scale) : Math.min(result, refFontSize * scale) - offset / 2;\n      }\n    }\n\n    topResult = Math.floor(topResult);\n  } else {\n    if (height) {\n      return {\n        paddingTop: Math.max(0, (height - fontSize) / 2),\n        paddingBottom: Math.max(0, (height - fontSize) / 2)\n      };\n    }\n\n    if (!isAndroid) {\n      if (dense) {\n        result += scale < 1 ? Math.min(offset / 2, fontSize / 2 * scale) : Math.min(offset / 2, scale);\n      }\n\n      if (!dense) {\n        result += scale < 1 ? Math.min(offset, fontSize * scale) : Math.min(fontSize, offset / 2 * scale);\n      }\n\n      result = Math.floor(result);\n      topResult = result;\n      bottomResult = result;\n    }\n  }\n\n  return {\n    paddingTop: Math.max(0, topResult),\n    paddingBottom: Math.max(0, bottomResult)\n  };\n};\nexport var interpolatePlaceholder = function interpolatePlaceholder(labeled, hasActiveOutline) {\n  return labeled.interpolate({\n    inputRange: [0, 1],\n    outputRange: [hasActiveOutline ? 0 : 1, 1]\n  });\n};","map":{"version":3,"mappings":"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","names":["calculateLabelTopPosition","labelHeight","height","optionalPadding","customHeight","Math","floor","calculateInputHeight","minHeight","finalHeight","calculatePadding","props","multiline","result","calculateTextAreaPadding","calculateInputPadding","max","dense","topPosition","fontSize","scale","offset","isAndroid","refFontSize","min","adjustPaddingOut","pad","label","paddingTop","paddingBottom","adjustPaddingFlat","styles","topResult","bottomResult","interpolatePlaceholder","labeled","hasActiveOutline","interpolate","inputRange","outputRange"],"sources":["helpers.tsx"],"sourcesContent":["import { Animated } from 'react-native';\n\ntype PaddingProps = {\n  height: number | null;\n  labelHalfHeight: number;\n  multiline: boolean | null;\n  dense: boolean | null;\n  topPosition: number;\n  fontSize: number;\n  label?: string | null;\n  scale: number;\n  offset: number;\n  isAndroid: boolean;\n  styles: { paddingTop: number; paddingBottom: number };\n};\n\ntype AdjProps = PaddingProps & {\n  pad: number;\n};\n\nexport type Padding = { paddingTop: number; paddingBottom: number };\n\nexport const calculateLabelTopPosition = (\n  labelHeight: number,\n  height: number = 0,\n  optionalPadding: number = 0\n): number => {\n  const customHeight = height > 0 ? height : 0;\n\n  return Math.floor((customHeight - labelHeight) / 2 + optionalPadding);\n};\n\nexport const calculateInputHeight = (\n  labelHeight: number,\n  height: any = 0,\n  minHeight: number\n): number => {\n  const finalHeight = height > 0 ? height : labelHeight;\n\n  if (height > 0) return height;\n  return finalHeight < minHeight ? minHeight : finalHeight;\n};\n\nexport const calculatePadding = (props: PaddingProps): number => {\n  const { height, multiline = false } = props;\n\n  let result = 0;\n\n  if (multiline) {\n    if (height && multiline) {\n      result = calculateTextAreaPadding(props);\n    } else {\n      result = calculateInputPadding(props);\n    }\n  }\n\n  return Math.max(0, result);\n};\n\nconst calculateTextAreaPadding = (props: PaddingProps) => {\n  const { dense } = props;\n\n  return dense ? 10 : 20;\n};\n\nconst calculateInputPadding = ({\n  topPosition,\n  fontSize,\n  multiline,\n  scale,\n  dense,\n  offset,\n  isAndroid,\n}: PaddingProps): number => {\n  const refFontSize = scale * fontSize;\n  let result = Math.floor(topPosition / 2);\n\n  result =\n    result +\n    Math.floor((refFontSize - fontSize) / 2) -\n    (scale < 1 ? offset / 2 : 0);\n\n  if (multiline && isAndroid)\n    result = Math.min(dense ? offset / 2 : offset, result);\n\n  return result;\n};\n\nexport const adjustPaddingOut = ({\n  pad,\n  multiline,\n  label,\n  scale,\n  height,\n  fontSize,\n  dense,\n  offset,\n  isAndroid,\n}: AdjProps): Padding => {\n  const refFontSize = scale * fontSize;\n  let result = pad;\n\n  if (height) {\n    return {\n      paddingTop: Math.max(0, (height - fontSize) / 2),\n      paddingBottom: Math.max(0, (height - fontSize) / 2),\n    };\n  }\n  if (!isAndroid && multiline) {\n    if (dense) {\n      if (label) {\n        result += scale < 1 ? Math.min(offset, (refFontSize / 2) * scale) : 0;\n      } else {\n        result += 0;\n      }\n    }\n    if (!dense) {\n      if (label) {\n        result +=\n          scale < 1\n            ? Math.min(offset, refFontSize * scale)\n            : Math.min(offset / 2, refFontSize * scale);\n      } else {\n        result += scale < 1 ? Math.min(offset / 2, refFontSize * scale) : 0;\n      }\n    }\n    result = Math.floor(result);\n  }\n  return { paddingTop: result, paddingBottom: result };\n};\n\nexport const adjustPaddingFlat = ({\n  pad,\n  scale,\n  multiline,\n  label,\n  height,\n  offset,\n  dense,\n  fontSize,\n  isAndroid,\n  styles,\n}: AdjProps): Padding => {\n  let result = pad;\n  let topResult = result;\n  let bottomResult = result;\n  const { paddingTop, paddingBottom } = styles;\n  const refFontSize = scale * fontSize;\n\n  if (!multiline) {\n    // do not modify padding if input is not multiline\n    if (label) {\n      // return const style for flat input with label\n      return { paddingTop, paddingBottom };\n    }\n    // return pad for flat input without label\n    return { paddingTop: result, paddingBottom: result };\n  }\n\n  if (label) {\n    // add paddings passed from styles\n    topResult = paddingTop;\n    bottomResult = paddingBottom;\n\n    // adjust top padding for iOS\n    if (!isAndroid) {\n      if (dense) {\n        topResult +=\n          scale < 1\n            ? Math.min(result, refFontSize * scale) - result / 2\n            : Math.min(result, refFontSize * scale) - result / 2;\n      }\n      if (!dense) {\n        topResult +=\n          scale < 1\n            ? Math.min(offset / 2, refFontSize * scale)\n            : Math.min(result, refFontSize * scale) - offset / 2;\n      }\n    }\n    topResult = Math.floor(topResult);\n  } else {\n    if (height) {\n      // center text when height is passed\n      return {\n        paddingTop: Math.max(0, (height - fontSize) / 2),\n        paddingBottom: Math.max(0, (height - fontSize) / 2),\n      };\n    }\n    // adjust paddings for iOS if no label\n    if (!isAndroid) {\n      if (dense) {\n        result +=\n          scale < 1\n            ? Math.min(offset / 2, (fontSize / 2) * scale)\n            : Math.min(offset / 2, scale);\n      }\n      if (!dense) {\n        result +=\n          scale < 1\n            ? Math.min(offset, fontSize * scale)\n            : Math.min(fontSize, (offset / 2) * scale);\n      }\n\n      result = Math.floor(result);\n      topResult = result;\n      bottomResult = result;\n    }\n  }\n\n  return {\n    paddingTop: Math.max(0, topResult),\n    paddingBottom: Math.max(0, bottomResult),\n  };\n};\n\nexport const interpolatePlaceholder = (\n  labeled: Animated.Value,\n  hasActiveOutline: boolean | undefined\n) =>\n  labeled.interpolate({\n    inputRange: [0, 1],\n    outputRange: [hasActiveOutline ? 0 : 1, 1],\n  });\n"]},"metadata":{},"sourceType":"module"}